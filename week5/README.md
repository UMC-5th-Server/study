- Persistence
  - 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성. 즉, 영속성
- Persistence Layer를 구현하는 방법

  - JDBC (Java Database Connectivity)

    - 자바에서 데이터베이스에 접속할 수 있도록하는 자바 API
    - 자바 애플리케이션에서 DBMS의 종류에 상관 없이 하나의 JDBC API를 이용해 DB 작업을 처리. 각각의 DBMS는 이를 구현한 JDBC 드라이버를 제공함. JDBC 인터페이스를 구현한 각각의 DBMS 드라이버만 갈아끼우면 어느 DB에서든 접근 가능.
    - 즉, JDBC API를 사용할 경우, 하나의 자바 응용 프로그램에서 JDBC 드라이버를 제공하는 어떤 종류의 관계형 DBMS에도 접근이 가능.
    - 드라이버 연결 → DB와 연결하는 통로 역할을 할 Connection 객체 생성 → Statement 객체 생성 후 이를 통해 쿼리문을 생성 및 실행함 → 이 SQL문에 결과물이 있다면 ResultSet 객체를 생성하고 필요한 데이터를 얻었음. → 이에 대한 작업이 끝나면 열었던 반대 순서로 자원을 해제해주는 과정을 거쳐 DB 처리를 진행함

    - 단점
      - 간단한 SQL을 실행하는 데도 중복된 코드를 반복적으로 사용
      - DB에 따라 일관성 없는 정보를 가진 채로 SQLException 처리
      - Connection과 같은 공유 자원을 제대로 반환해주지 않으면 시스템의 자원이 바닥나는 버그 발생. 따라서 이를 수동으로 닫아주어야함

  - Persistence Framework
    - JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발
    - 모든 Persistence framework는 내부적으로 JDBC API를 이용하는데, 이를 SQL Mapper 와 ORM으로 나눌 수 있음.

      - SQL Mapper
        - 객체(Object)와 SQL문을 매핑하여 데이터를 객체화하는 것.
        - 객체와 관계를 매핑하는 것이 아닌 직접 작성한 SQL문의 질의결과와 객체의 필드를 매핑하여 데이터를 객체화하는 것
        - Spring JDBC → SQL Mapper 기능 제공
          - JDBC Template을 사용함으로써 쿼리 수행 결과와 객체의 필드를 매핑하여 반환받을 수 있고 이때 사용되는 RowMapper를 재활용할 수 있음.
          - JDBC에서 반복적으로 해야하는 많은 작업들을 대신 해주어서 실행할 SQL과 바인딩할 파라미터를 넘겨주거나 쿼리 실행 결과를 어떤 객체에 넘겨 받을 지를 지정만 하면 됨.
        - SQL Mapper에 속하는 대표적인 프레임 워크 → MyBatis
          - 반복적인 JDBC 프로그래밍을 단순화
          - SQL 쿼리들을 XML 파일에 작성하여 코드와 SQL을 분리하여 관리
          - 순수 JDBC만 사용하면 결과를 가져와서 객체의 인스턴스에 매핑하기 위한 많은 코드가 필요하겠지만 MyBatis는 그 코드들을 작성하지 않아도 되게 해줌
          - 동적 쿼리 지원. 복잡한 쿼리 또는 다이나믹하게 변경되는 쿼리 작성 쉽게 할 수 있음
            \*\* spring boot에서 이를 사용할 경우, DB 접근하기 위한 별다른 작업없이 보라색 부분인 mapper 인터페이스와 mapping file만 구현하면, 자연스럽게 객체의 필드와 SQL문이 매핑됨.
            mapper 인터페이스에 대한 구현체는 우리가 구현하지 않아도 MyBatis에서 자동으로 생성하게 됨.
        - persistence framework인 MyBatis를 사용하면서 (자동으로 Connection 관리를 해주면서) JDBC만을 사용했을 때 작성했던 중복되는 작업 대부분을 없애줌.
        - 복잡한 쿼리나 다이나믹하게 변경되는 쿼리 작성이 쉬움
        - DAO로부터 SQL문을 분리하여 코드의 간결성 및 유지보수성 향상시킴 (→ 관심사 분리)
          <aside>
          💡 but, JDBC와 SQL Mapper 모두 SQL을 개발자가 직접 작성함으로써 문제점이 생김.
          
          - DB에 종속적이지 않는 것이 JDBC의 컨셉이었으나 사용하는 쿼리 문법이나 데이터 타입은 DB마다 다르기 때문에 쿼리문을 직접 작성할 경우, 결국 특정 DB에 종속적으로 사용하게 되어버림.
          - DB에 종속적이지 않는 것이 JDBC의 컨셉이었으나 사용하는 쿼리 문법이나 데이터 타입은 DB마다 다르기 때문에 쿼리문을 직접 작성할 경우, 결국 특정 DB에 종속적으로 사용하게 되어버림.
          - 테이블마다 비슷한 CRUD 작업이 계속해서 일어나는데, 이를 개발자가 일일이 쿼리를 작성하며 반복적인 DAO 개발을 피할 수 없게 됨.
          - 테이블 필드가 변경될 시 이와 관련된 DAO의 SQL문, 객체 필드 등을 개발자가 직접 일일이 수정해야 함.
          - 즉, DAO와 SQL문을 분리함으로써 SQL문을 숨길 수 있었지만 이러한 상황에서는 어쩔 수 없이 DAO를 열어서라도 확인해야함. 따라서 코드상으로는 SQL과 JDBC API를 분리했다 하더라도 논리적으로 강한 의존성을 가지고 있음.
          - 또한, SQL문을 직접 작성하게 되면 SQL 의존적인 설계를 할 수 밖에 없는데, 객체 간의 관계는 사라지고 데이터베이스에 대한 처리에 집중하게 되어버림. 즉, 비즈니스 로직 구현보다 데이터베이스 접근 로직 구현에 집중하며 데이터베이스에 항상 의존 관계를 가질 수 밖에 없음.
          
          </aside>
          
          > ⇒ **패러다임 불일치**
          (관계형 데이터베이스는 객체 구조와는 다른 데이터 중심의 구조를 가지고 있어 추상화, 상속, 다형성 같은 개념을 가진 객체를 데이터베이스에 직접 저장하거나 조회하기에는 어려움이 있음. 객체와 관계형 데이터베이스는 각각 지향하는 목적이 다르기에 사용방법과 표현 방식에 차이가 있어 객체의 구조를 테이블 구조에 저장하는데에는 한계가 있음)
          > 

      - ORM
        - 객체와 관계형 데이터베이스를 매핑하는 것
        - 패러다임 불일치 문제를 ORM은 객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하고 직관적인 메서드로 데이터를 조작하게 하여 개발자의 불편 없이 해결 할 수 있음.
        - 대표적인 예 → JPA
          - JPA
            - 자바 ORM 기술에 대한 API 표준 명세로, 인터페이스들을 모아둔 것.
            - JPA 기술을 사용하려면 JPA 인터페이스를 구현한 ORM 프레임 워크를 사용하여함. 이를 구현한 프레임 워크 → 하이버네이트 (가장 대중적), 이클립스 링크 등
        - 패러다임 불일치 문제
          - 상속
            - 관계형 데이터베이스 테이블은 상속이라는 기능이 없음.
            - 그나마 데이터베이스 모델링에서 이야기하는 공통의 부분을 슈퍼타입으로 묶고 공통으로부터 상속받아 다른 엔티티와 차이가 있는 속성에 대해서는 별도의 서브엔티티로 구현하는 관계를 사용하면 상속과 가장 유사한 형태로 테이블 설계 가능.
              → insert시 총 2번, select할때는 join 해야함. 즉, 쿼리문 점점 복잡
            - 따라서 JPA로 해결
              - 상속 관계에 있는 객체를 저장하기 위해 우리가 일일이 작성했던 쿼리들을 JPA가 알아서 해줌.
          - 연관관계
            - 객체는 참조를 사용해 다른 객체와 연관관계 가짐
            - 관계형 데이터베이스 테이블을 외래키를 통해 다른 테이블과 연관관계 가지고 조인을 사용해 연관된 테이블을 조회
            - 따라서 JPA로 해결
              - 둘 간의 관계를 설정하고 persist()라는 메서드로 객체를 저장하기만 하면 됨. JPA가 참조를 외래키로 변환하여 insert문을 날리고, 조회할 때도 JPA가 내부적으로 select 문을 외래키를 참조로 변환하여 처리하게 됨.
          - 객체 그래프 탐색
            - 객체 내에서는 그래프 탐색을 자유롭게 할 수 있지만, SQL을 다룰 때는 작성한 쿼리에 따라 객체의 그래프 탐색의 범위가 제한되게 되는 문제가 발생하게 됨.
            - 따라서 JPA로 해결
              - JPA가 제공하는 메소드를 사용하여 연관된 객체를 조회하면 적절한 조회 쿼리를 알아서 실행하기 때문에 연관된 객체를 신뢰하며 자유로운 탐색 가능
          - 객체 간 비교
            - 데이터베이스는 기본 키의 값으로 각 로우의 동일성을 구분하지만, 객체는 주소 값 비교인 동일성 비교와 객체 내부의 값을 비교하는 동등성 비교 이렇게 두 가지가 있음.
            - JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장함.
        ORM을 사용하여 분리된 설계 즉, 데이터베이스에 의존하지 않은 상태에서 개발할 경우, 도메인과 비즈니스 로직 구현에 좀 더 집중할 수 있음. 데이터베이스 서버와 의존 관계를 가지지 않는 구현 단계를 거치면서 더 빠른 구현과 테스트인 피드백 사이클을 돌 수 있으며 요구사항의 변화에 빠르게 대응할 수 있다.
